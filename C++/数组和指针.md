# 一维数组

定义方式：

1. 数据类型 数组名 [数组长度];
2. 数据类型 数组名[数组长度] = {值1，值2，……};
3. 数据类型 数组名[.]={值1，值2，……};

数组特点：

1. 放在一块连续的内存空间中
2. 数组中每个元素都是相同的数据类型
3. 定义数组的时候必须要有初始长度
4. 数组中索引的开始为0\
5. 数组中数值不够数组定义的长度，剩余位补为0

```c++
int arr[3];//没有初始长度
int arr[3]={10,20,30,14,456,698,65,};//这才是正确的
```

##  一维数组数组名

用途：

1. 可以统计整个数组在内存中的长度，即获取整个数组占用内存空间大小
2. 可以获取数组在内存中的首地址
3. 数组名是常量，不可以进行赋值操作

### 冒泡排序

作用：最常用的排序算法，对数组内元素进行排序

1. 比较相邻的元素，如果第一个比第二个大，就吉奥换他们两个
2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。
3. 重复以上步骤，每次比较次数-1，直到不需要比较

```c++
#include <iostream>
using namespace std;
int main() {
	//冒泡排序
	int arr[9] = { 4,2,8,6,5,7,1,3,9 };
	cout << "排序前：" << endl;
	for (int i = 0; i < 9; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	//开始冒泡排序
	//总共排序轮数为：元素个数-1
	for (int i = 0; i < 9 - 1; i++)
	{
		//内存循环比外层循环次数=元素个数-当前轮数-1
		for (int j = 0; j < 9 - i - 1; j++)
		{
			 //如果第一个数字，比第二个数字大，交换两个数字
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	//排序后结果
	cout << "排序后结果为：" << endl;
	for (int i = 0; i < 9; i++)
	{
		cout << arr[i] << " ";
	}
	return 0;
}
```

# 二维数组

##  二维数组的定义方式

1. 数据类型 数组名[ 行数 ] [ 列数 ];
2. 数据类型 数组名[ 行数 ] [ 列数 ] = { {数据1, 数据2} , {数据3, 数据4} };
3. 数据类型 数组名[ 行数 ] [ 列数 ] = { 数据1, 数据2, 数据3, 数据4 };
4. 数据类型 数组名[ ] [ 列数 ] = { 数据1, 数据2, 数据3, 数据4 };

> 建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性
>
> 在定义二维数组时，如果初始化了数据，可以省略行数

### 二维数组的数组名称

* 查看二维数组所占内存空间

```c++
#include <iostream>
using namespace std;
int main() {
	int arr[2][3] = { {1,2,3},{4,5,6} };
	cout << "二维数组占用内存空间为：" << sizeof(arr) << endl;
	cout << "二维数组第一行占用内存空间为：" << sizeof(arr[0]) << endl;
	cout << "二维数组第一个元素占用内存空间为:" << sizeof(arr[0][0]) << endl;
	cout << "二维数组的行数为:" << sizeof(arr) / sizeof(arr[0]) << endl;
	cout << "二维数组的列数为:" << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;
	return 0;
}
```

* 获取二维数组首地址

```c++
#include <iostream>
using namespace std;
int main() {
	int arr[2][3] = { {1,2,3},{4,5,6} };
	cout << "二维数组首地址为：" << (int)arr << endl;
	cout << "二维数组第一行首地址为：" << (int)arr[0] << endl;
	cout << "二维数组第二行首地址为：" << (int)arr[1] << endl;

	cout << "二维数组第一个元素的首地址为：" << (int)&arr[0][0] << endl;
	cout << "二维数组第二个元素的首地址为：" << (int)&arr[0][1] << endl;
	return 0;
}
```





# 指针

1. 原来的空指针为：NULL		现在的空指针新表示法为：nullptr

## 指针的基本概念

指针的作用：可以通过指针间接访问内存

* 内存编号是从0开始记录的，一般用十六进制数字展示
* 利用指针变量保存地址 

```c++
int main()
{
	//1、定义指针
	int a = 10;
	//指针定义的语法：数据类型 * 指针变量名;
	int* p;
	//让指针记录变量a的地址
	p = &a;
	cout << "a的地址为：" << &a << endl;
	cout << "p的值为：" << p << endl;

	//2、指针的解引用
	//指针前加*，代表解引用，找到指针指向的内存空间
	system("pause");
	return 0;
}
```

## 指针所占内存空间

```c++
#include <iostream>
using namespace std;
//指针所占内存空间
int a = 10;
//int *p;
//p=&a;
int* p = &a;//等价上边两条注释代码
 
```

### 空指针和野指针

空指针：指针变量指向内存编号为0的空间

用途：初始化指针变量

注意：空指针指向的内存是不能被访问的，且空指针和野指针都不是申请的空间，因此不要访问



### const修饰指针

有三种情况：

1. const修饰指针  —-常量指针

格式：

```c++
const int *p=&a;
```

特点：指针的指向可以修改，但是指针指向的值不可以改

2. const修饰常量  —–指针常量

格式为：

```c++
int * const p=&a;
```

特点：指针的指向不可以改，指针指向的值可以改

3. const即修饰指针 —-又修饰常量

格式：

```c++
const int * const p=&a; 
```

特点：指针的指向和指针指向的值都不可以改

```c++
#include <iostream>
using namespace std;

int main()
{
	// 1、const修饰指针   常量指针	指针指向的值不能改变，但是指针本身可以改变
	int a = 10;
	int b = 10;
	const int* p = &a;
	//*p = 20;//错误
	p = &b;//正确
	// 2、const修饰常量   指针常量	指针的指向不能改变，但是指针指向的值可以改变
	int* const p2 = &a;
	*p2 = 100;//正确
	//p2 = &b;//错误

	// 3、const修饰指针又修饰常量  指针指向的值不能改变，指针本身也不能改变
	const int* const p3 = &a;
	//*p3 = 200;//错误
	//p3 = &b;//错误
}
```

总结：看const右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量	 

## 指针和数组

作用：利用指针访问数组中元素

 ```c++
 #include <iostream>
 using namespace std;
 
 int main()
 {
 	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
 	int* p = arr;
 	cout << *p << endl;
 }
 ```

## 指针和函数

作用：利用指针做函数参数，可以修改实参的值

```c++
#include <iostream>
using namespace std;
//值传递，和地址传递
void swap01(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;
}
void swap02(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}
int main()
{
	int a = 10;
	int b = 20;
	swap01(a, b);
	cout << "值传递" << endl;
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	//地址传递 
	//地址传递可以修改实参的值
	int c = 10;
	int d = 20;
	swap02(&c, &d);
	cout << "地址传递" << endl;
	cout << "c = " << c << endl;
	cout << "d = " << d << endl;
}
```

总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递

