# 数据链路层

## 数据链路层基本概念

结点：主机、路由器

链路：网络中两个节点之间的物理通道，而中间没有任何其他的交换节点，链路的传输介质主要有双绞线、光纤和微波。分为有限链路、无线链路。

数据链路：网络中两个节点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。

帧：链路层对等实体之间在水平方向上进行逻辑通信的协议数据单元（PDU） 的协议数据单元（PDU)，封装网络层数据报。

计算机中的网络适配器（网卡）和相应的软件驱动程序就实现了这些协议。一般的网络适配器都包含了物理层和数据链路层这两层的功能。

数据链路层负责通过一条链路从一个结点向另一个物理链路直接互联的相邻节点传送数据报。 

### 数据链路层的三个重要问题

#### 封装成帧

 ~~~ mermaid
 graph LR
 发送方的应用层的应用层协议数据单元  --运输层首部--> 网络层 --添加网络层首部 --> 数据链路层 -- 链路层尾部和首部 --> 封装成帧
 ~~~

链路层首部和尾部包含有一些重要的控制信息。

 例如：

| 以太网V2的MAC帧（最大长度1518B） |
| :------------------------------: |

| 4   B | 46 —1500B | 2B   | 6B     | 6B       |
| ----- | --------- | ---- | ------ | -------- |
| FCS   | 数据载荷  | 类型 | 源地址 | 目的地址 |

封装成帧是指数据链路层给上层交付下来的协议数据单元PDU添加一个首部一个尾部，使之称为帧。

* 帧的首部和尾部中包含有一些重要的控制信息。
* 帧首部和尾部的作用之一就是帧定界。
* 并不是每一种数据链路层协议的帧都包含有帧定界。
* 为了提高数据链路层传输帧的效率，应当使<font color="orange">帧的数据载荷的长度尽可能地大于首部和尾部的长度。</font>
* 考虑到对缓存空间的需求以及差错控制等诸多因素，每一种数据链路层协议都规定了帧的数据载荷的长度上限，即最大传送单元（MTU）



#### 透明传输

透明传输是指<font color="orange">数据链路层对上层交付下来的协议数据单元PDU没有任何限制</font>，就好像数据链路层不存在一样。

* 面向字节的物理链路使用<font color="orange">字节填充</font>的方法实现透明传输。

![image-20241113172408543](./assets/image-20241113172408543.png)

* 面向比特的物理链路使用<font color="orange">比特填充</font>的方法实现透明传输。

![image-20241113172420695](./assets/image-20241113172420695.png)

#### 差错控制

误码：相关概念

* 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错（称为比特差错）
    * 比特1可能变成0
    * 比特0可能变成1
* 在一段时间内，传输错误的比特数量占所传输比特总数的比率称为误码率
* 提高链路的信噪比，可以降低误码率。但在实际的通信链路上，不可能使误码率下降为0
* 使用差错检测技术来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。

##### 奇偶校验

* 奇校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为奇数。

![image-20241125093654511](./assets/image-20241125093654511.png)

* 在所传输的数据中，如果有奇数个位发生误码，则所包含比特1的数量的奇偶性会发生改变，可以检测出误码。



* 偶校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为偶数,

![image-20241125093721645](./assets/image-20241125093721645.png)

* 在所传输的数据中，如果有偶数个位发生误码，则所包含比特1的数量的奇偶性不会发生改变，无法检测出误码(漏检)
* 在实际使用时，奇偶校验又可分为垂直奇偶校验、水平奇偶校验以及水平垂直奇偶校验

##### 循环冗余校验

* 数据链路层广泛使用漏检率极低的循环冗余校验(CRC)检错技术
* 循环冗余校验CRC的基本思想：
    * 收发双方约定好一个生成多项式G(X)。
    * 发送方基于待发送的数据和生成多项式G(X)，计算出差错检测码
        冗余码)，将冗余码添加到待发送数据的后面一起传输。
    * 接收方收到数据和冗余码后，通过生成多项式G(X)来计算收到的数据和冗余码是否产生了误码。

发送CRC操作

生成多项式各项系数构成的比特串/待发送的数据+生成多项式最高次个0，得到商（注：商仅作为标记，防止计算过程对错位）和余数（长单应与生成多项式最高次数相同，作为冗余码）

将余数和待发送的数据拼接到一起进行发送



接收方CRC操作

生成多项式各项系数构成的比特串/已接收的数据+余数，得到商和余数，余数位0可判断接收无误码，余数不为0可判断接收有误码

 

![image-20241125095403249](./assets/image-20241125095403249.png)

## 可靠传输的相关基本概念

* 使用差错检测技术（例如循环冗余校验CRC）,接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特差错）。
* 数据链路层向其上层提供的服务类型
    * 不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做
    * 可靠传输服务：通过某种机制实现发送方发送什么，接收方最终就能收到什么，
    * 一般情况下，有线链路的误码率比较低。为了减小开销，并不要求数据链路层向其上层提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。
    * 无线链路易受干扰，误码率比较高，因此要求数据链路层必须向其上层提供可靠传输服务。
    * 可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输。
    * 可靠传输的实现比较复杂，开销比较大，是否使用可靠传输取决于应用需求

### 停止-等待协议的实现原理

##### 传送门：[3.2.3 （2）可靠传输的实现机制 - 停止-等待协议_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1NT411g7n6?spm_id_from=333.788.videopod.episodes&vd_source=64709a8217a1bbd540960dd246f1356a&p=23)

![image-20241125103435256](./assets/image-20241125103435256.png)

注意事项：

* 使用超时重传机制后，就可以不使用否认机制了，这样可使协议实现起来更加简单。但是，如果点对点链路的误码率较高，使用否认机制可以使发送方在超时计时器超时前就尽快重传。
* 为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的特性，只需1个比特编序号即可，即序号0和序号1。
* 为了让发送方能够判断所收到的确认分组是否是重复的，需要给确认分组编号，所用比特数量与数据分组所用比特数量一样。
    * 数据链路层一般不会出现确认分组迟到的情况，因此在数据链路层实现停止·等待协议可以不用给确认分组编号
* 给超时计时器设置的超时重传时间RTO应当仔细选择，一般将RTO设置为略大于收发双方的平均往返时间RTT.
    * 在数据链路层，点对点的往返时间RTT比较固定，RTO就比较好设定
    * 在运输层，由于端到端往返时间非常不确定，设置合适的超时重传时间RTO有时并不容易。
* 停止·等待协议属于自动请求重传(Automatic RepeatreQuest，ARQ)协议。即重传的请求是发送方自动进行的，而不是接收方请求发送方重传某个误码的数据分组.

#### 停止-等待协议的信道利用率

$T_D$:发送方发送数据分组所耗费的发送时延

RTT：是信号在收发双方之间往返传播所耗费的时间

$T_A$:接收方发送确认分组所耗费的发送时延

![image-20241125114318061](./assets/image-20241125114318061.png)

![image-20241125114344656](./assets/image-20241125114344656.png)

* 若出现超时重传，对于传送有用的数据信息来说，信道利用率还要降低
* 在往返时间RTT相对较大的情况下，为了提高信道利用率，收发双方不适合采用停止·等待协议，而可以选择使用回退N帧(GBN)协议或选择重传(SR)协议。

### 回退N帧协议

![image-20241207125536868](./assets/image-20241207125536868.png)

* 在使用流水线传输方式时吗，发送方不能无限制地连续发送数据分组，否则可能会导致网络中地路由器或接收方来不及处理这些数据分组，进而导致数据分组的丢失，这实际上是对网络资源地浪费。因此，必须采取措施来限制发送方连续发送数据分组地数量。
* 回退N帧协议采用流水线传输方式。并且利用发送窗口来限制发送方连续发送数据分组地数量，这属于连续ARQ协议。

```mermaid
graph LR
接收方 --因特网 -->发送方
```

* 采用n个比特给分组编序号，序号范围时0\~（2<sup>n</sup>-1)。本例假设采用3个比特给分组编序号，则序号范围是0~7。
* 发送方需要维护一个<font color="pink">发送窗口$W_t$</font>，在未收到接收方确认分组的情况下，发送方可将序号落入$W_t$内的所有数据分组连续发送出去
    * 采用n个比特给分组便序号，则$W_T$的取值范围时<font color="liblue">1 <$W_T$ &le; (2<sup>n</sup>-1)</font>。本例假设采用3个比特给分组便序号，则$W_T$的取值范围是2~7,本例取$W_T$​=5。
    * 接收方需要维护一个<font color="orange">接收窗口$W_R$</font>,只有正确达到接收方（无误码）且序号落入$W_R$内的数据分组才被接收方接收。
        * <font color="orange">$W_R$​的取值只能是1</font>，这一点与停止-等待协议是相同的。
* 接收方每正确收到一个序号落入接收窗口的数据分组，就将接收窗口向前滑动一个位置，这样就有一个新的序号落入接收窗口，与此同时，接收方还要给发送方发送针对该数据分组的确认分组。
* 发送方每收到一个按序确认的确认分组，就将发送窗口向前滑动一个位置，这样就有一个新的序号落入发送窗口，序号落入发送窗口内的数据分组可继续被发送。
* 在回退N帧协议的工作过程中，发送方的发送窗口和接收方的接收窗口按上述规则不断向前滑动。因此，这类协议又称为<font color="red">滑动窗口协议</font>

在无传输差错的情况下，回退N帧协议的信道利用率比停止-等待协议的信道利用率有显著提升。提高的成都却决于发送窗口的大小。

但是一个数据分组的差错就可能引起大量数据分组的重传。在信道质量较差（容易出现误码）的情况下，回退N帧协议的信道利用率并不比停止-等待协议的信道利用率高。

* 回退N帧协议的接收方采用累计确认方式。
    * 接收方不必对收到的每一个数据分组都发送一个确认分组，而是可以在收到几个序号连续的数据分组后，对按序到达的最后一个数据分组发送确认分组。
    * 接收方合适发送累积确认分组，有具体实现决定
    * 确认分组$ACK_n$​表明序号为n及之祈安的所有数据分组都已正确接收。
* 累积确认的优点：
    * 减少向网络中注入确认分组的数量。
    * 即使确认分组丢失，也可能不必重传数据分组
* 累积确认的缺点：
    * 不能向发送方及时准确地反映出接收方已正确接收地所有数据分组地数量。 

### 选择重传协议

假设采用3个比特给分组编序号，则序号范围是0~(2&sup3;-1)。

<font color="lightpink">接收窗口$W_R$</font>取最大值2<sup>(3-1)</sup>,即$W_R$=4.

<font color="lightblue">发送窗口$W_R$</font>能取到地最大值也为2<sup>(3-1)</sup>,即$W_T$=4

故意取$W_T$，使得$W_T$+$W_R$&ge;2&sup3;,接收方将无法分辨新旧数据分组。





## 点对点协议PPP

* 是目前使用最广泛地点对点数据链路层协议

* 点对点协议于1992年指定。目前PPP已成为因特网地正是标准

* 点对点协议PPP主要有两种应用：

    * ```mermaid
        graph LR
        因特网用户 --PPP协议 --> ISP-->因特网
        ```

    * 应用于广域网链路：
    
    ```mermaid
    graph LR
    1(路由器) -- PPP协议 --> 2(路由器)
    ```

* 从网络体系结构的角度看点对点协议PPP的组成
    $$
    \begin {cases}
    网络层
    \begin {cases}
    TCP/IP中的IP\\
    Novell NetWare网络操作系统中的IPX\\
    Apple公司的ApleTalk
    \end{cases}\\
    数据链路层PPP
    \begin {cases}
    一套网络控制协议NCP_S\\
    一个网络层PDU封装到串行链路的方法\\
    一个链路控制协议LCP
    \end {cases}\\
    物理层
    \begin {cases}
    面向字节的异步链路\\
    面向比特的同步链路
    \end {cases}
    \end {cases}
    $$
    

