# 基本类型

Rust 每个值都有其确切的数据类型，分为两类：基本类型和复合类型。基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型（一般意义上来说），由以0下组成：

* 数值类型：有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数。
* 字符串：字符串字面量和字符串切片`&str`
* 布尔类型：`True`和`false`
* 字符类型：表示单个Unicode字符，存储为4个字节。
* 单元类型：即(),其唯一的值也是()



## 类型推导与标注

Rust是一门金泰类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但不是为每个变量都指定类型，因为**Rust回根据变量值和上下文中的使用方式来自动推导出变量的类型**，但是在某些情况下，它无法推导出变量类型，需要手动给予一个类型标注。

```rust
let guess = "42".parse().expect("Not a number!");
```

先忽略 `.parse().expect..` 部分，这段代码的目的是将字符串 `"42"` 进行解析，而编译器在这里无法推导出我们想要的类型：整数？浮点数？字符串？因此编译器会报错：

因此我们需要提供给编译器更多的信息，例如给 `guess` 变量一个**显式的类型标注**：`let guess: i32 = ...` 或者 `"42".parse::<i32>()`。



## 数值类型

Rust使用一个相对传统的语法来创建整数（1，2，……）和浮点数（1.0`，`1.1，……）。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。

```
不仅仅是数值类那个，Rust也允许在复杂类型上定义运算符，例如在自定义类型上定义+运算符，这种行为被称为运算符重载
```

Rust具体支持的可重载运算符见[运算符与符号 - Rust语言圣经(Rust Course)](https://course.rs/appendix/operators.html#运算符)

### 整数类型

整数是没有小数部分的数字。之前使用的`i32`类型，表示有符号的32位整数（`i`是英文单词integer的首字母，与之相反的是`u`，代表无符号类型）

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8位        | `i8`       | `u8`       |
| 16位       | `i16`      | `u16`      |
| 32位       | `i32`      | `u32`      |
| 64位       | `i64`      | `u32`      |
| 128位      | `i128`     | `u128`     |
| 视架构而定 | `isize`    | `usize`    |

类型定义的形式统一为：`有无符号+类型大小（位数）`。**无符号数**表示数字只能取整数和0，而**有符号**则表示数字可以取正数、负数还有0。就像在指上写数字一样：当腰强调符号时，数字前面可以带上正好或符号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以*补码*形式存储。

每个有符号类型规定的数字范围是-(2<sup>n-1</sup>)~2<sup>n-1</sup>-1，其中`n`是该定义形式的位长度。因此`i8`可存储数字范围时-(2<sup>7</sup>) \~ 2<sup>7</sup>-1，即`-128 ~127`。无符号类型可以存储的数字范围是0 ~ 2<sup>n</sup>-1，所以`u8`能够存储的数字为0 ~2<sup>8</sup>-1，即0 \~ 255。

此外，`isize`和`usize`类型取决于程序运行的计算机CPU类型：若CPU是32位的，则这两个类型是32位的，同理，若CPU是64位，那么它们则是64位。

| 数字字面量        | 示例          |
| ----------------- | ------------- |
| 十进制            | `98_222`      |
| 十六进制          | `0xff`        |
| 八进制            | `0o77`        |
| 二进制            | `0b1111_0000` |
| 字节（仅限于`u8`) | `b'A'`        |

这么多类型，Rust整型默认使用`i32`，例如`let i=1`,那`i`就是`i32`类型，因此可以首选它，同时 该类型也往往是性能最好的。`isize`和`usize`的主要应用长江是用作集合的索引。

#### 整型溢出

假设有一个`U8`,它可以存放从0到255的值。那么当修改其范围之外的值，比如256，则会发生**整型溢出**。关于这一行为Rust有一些规则：当在debug模式编译时，Rust会检查整型溢出，若存在这些问题，则使程序在编译时panic（崩溃，Rust使用这个术语来表明程序因错误而退出）。

当使用`--release`参数进行release模式构建时，Rust不检测溢出。相反，当检测到整型溢出时，Rust会在哪找补码循环溢出的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在`u8`的情况下，256变成0，257变成1，依此类推。程序不会panic,但是该变量的值可能不是期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。

要显示处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

* 使用`wrapping_*`方法在所有模式下都按照补码循环溢出规则处理，例如`warapping_add`
* 如果使用`checked_*`方法时发生溢出，则返回`None`值
* 使用`overflowing_*`方法返回该值和一个指示是否存在在溢出的布尔值
* 使用`saturating_*`方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如：

```rust
assert_eq!(100u8.saturating_add(1), 101);
assert_eq!(u8::MAX.saturating_add(127), u8::MAX);
```

下面是一个演示`warapping_*`方法的示例：

```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}
```

## 浮点类型

**浮点类型数字**是带有小数点的数字，在Rust中浮点类型数字也有两种基本类型：`f32`和`f64`,分别为32位和64位大小。默认浮点类型时`f64`，在现代的CPU中它的速度与`f32`几乎相同，但精度更高。

下main是一个演示浮点数的示例：

```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

浮点数根据`IEEE-754`标准实现。`f32`类型时单精度浮点型，`f64`为双精度。

### 浮点数陷阱

浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：

1. **浮点数往往是你想要数字的近似表达**浮点数类型是基于二进制实现的，但是想要计算的数字往往是基于十进制，例如`0,1`在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果想要表达精准的真实数字，只有使用无限精度的浮点数才行。
2. **浮点数在某些特性上是反直觉的**，它们确实可以使用 `>`，`>=` 等进行比较，但是在某些场景下，这种直觉上的比较特性反而不行。因为 `f32` ， `f64` 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征，但是后者在其它数值类型上都有定义，说了这么多，还是云里雾里，用一个例子来举例：

Rust的`HashMap`数据结构，是一个KV类型的Hash Map实现，它对于K没有特定类型的限制，但是要求能用作K的类型必须实现了`std::cmp::Eq`特征，因为这意味着无法使用浮点数作为`HashMap`的`Key`，来存储键值对，但是作为对比，Rust的整数类型、字符串类型、布尔类型都实现了该特征，因此可作为`HashMap`的`Key`。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

来看个小例子:

```rust
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
```

以上代码会Panic（程序崩溃，抛出异常),因为二进制精度问题，导致了0.1+0.2并不严格等于0.3，它们可能在小数点N位后存在误差。

如果非要比较的化，可以考虑`(0.1_f64 + 0.2 - 0.3).abs() < 0.00001`，具体小于多少，取决于对精度的需求。

```rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

```rust
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

对`f32`类型做加法时，`0.1+0.2`的结果是`3e99999a`,`0.3`也是`3e99999a`,因此`f32`下的`0.1+0.2 == 0.3`通过测试，但是到了`f64`类型时，结果就不一样了，因为`f64`精度高很多，因此在小数非常后面发生了一些微笑的变化，`0.1 +0.2`以`4`结尾，但是`0.3`以`3`结尾，这个细微区别导致`f64`下的测试失败了，并且抛出了异常。

#### NaN

对于数学上未定义的结果，例如对负数取平方根，`-42.1.sqrt()`，会产生一个特殊的结果：Rust的浮点数类型使用`NaN`（not a number）来处理这些情况。

所有跟`NaN`交互的操作，都会返回一个NaN，而且NaN不能用来比较，下面的代码会崩溃：
```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

出于防御性编程的考虑，可以使用`is_nan()`等方法，可以用来判断一个数值是否是NaN:

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

### 数字运算

Rust支持所有数字类型的基本数学运算：加减法、乘除法和取模运算。下面代码各使用一条`let`语句来说明相应运算的用法：

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 求余
    let remainder = 43 % 5;
}
```

这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上，[运算符与符号 - Rust语言圣经(Rust Course)](https://course.rs/appendix/operators.html#运算符)中给出了Rust提供的所有运算符列表。

这是一个综合性的示例：

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

### 位运算

Rust的位运算基本上和其他语言一样

| 运算符 |                          说明                          |
| :----: | :----------------------------------------------------: |
| &位与  |             相同位置均为1时则为1，否则为0              |
| \|位或 |            相同位置只要有1时则为1，否则为0             |
| ^异或  |              相同位置不同则为1，相同则为0              |
| ！位非 |         把位中的0和1相互取反，即0置为1，1置为0         |
| <<左移 |            所有位向左移动指定位数，右位补0             |
| >>右移 | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |

```rust
fn main() {
    // 无符号8位整数，二进制为00000010
    let a: u8 = 2; // 也可以写 let a: u8 = 0b_0000_0010;

    // 二进制为00000011
    let b: u8 = 3;

    // {:08b}：左高右低输出二进制01，不足8位则高位补0
    println!("a value is        {:08b}", a);

    println!("b value is        {:08b}", b);

    println!("(a & b) value is  {:08b}", a & b);

    println!("(a | b) value is  {:08b}", a | b);

    println!("(a ^ b) value is  {:08b}", a ^ b);

    println!("(!b) value is     {:08b}", !b);

    println!("(a << b) value is {:08b}", a << b);

    println!("(a >> b) value is {:08b}", a >> b);

    let mut a = a;
    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
    a <<= b;
    println!("(a << b) value is {:08b}", a);
}
```

### 序列（Range）

Rust提供了一个非常简洁的方式，用来生成连续的数值，例如`1..5`,生成从1到4的连续数字，不包含5；`1..=5`，生成从1到5的连续数字，包含5，它的用途很简单，常常用于循环红：

```rust
for i in 1..=5 {
    println!("{}",i);
}
```

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值时Rust中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：

```rust
for i in 'a'..='z' {
    println!("{}",i);
}
```

#### 使用As完成类型转换

Rust中可以是使用As来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成注入将指针转换位地址、地址转换为指针以及将指针转换为其他指针等功能。可以在 [类型转换 - Rust语言圣经(Rust Course)](https://course.rs/advance/into-types/converse.html)了解相关知识

##### 有理数和复数

Rust的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

* 有理数和复数
* 任意大小的整数和任意精度的浮点数
* 固定精度的十进制小数，常用于货币相关的场景

好在社区已经开发出高质量的Rust数值库：[num - crates.io: Rust Package Registry](https://crates.io/crates/num)

按照以下步骤来一如`num`库：

1. 创建新工程`cargo new complex-num && cd complex-num`
2. 在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = "0.4.0"`
3. 将 `src/main.rs` 文件中的 `main` 函数替换为下面的代码
4. 运行 `cargo run`

```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```

### 总结

之前提到了过Rust的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异。

* **Rust拥有相当多的数值类型**，因此需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及选择的类型是否能表达负数
* **类型转换必须是显式的**.Rust永远也不会把16Bit整数转换成32bit整数
* **Rust的树枝上可以使用方法**例如可以用一下方法将`13.14`取整：`13.14_f32.round()`,在这里我们使用了类型后缀，因为编译器需要知道`13.14`的具体类型

数值类型的讲解已经基本结束，接下来，看看字符和布尔类型





# 字符、布尔、单元类型

### 字符类型（char）

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let g = '国';
    let heart_eyed_cat = '😻';
}
```

Rust的字符不仅仅是`ASCII`，所有的`Unicode`值都可以作为Rust字符，包括单个的中文、日文、韩文、emoji表情符号等等，都是合法的字符类型。`Unicode`的值的范围从`U+0000 ~u+d7FF`和`U+E000 ~ U+10FFFF`。不过“字符”并不是`Unicode`中的一个概念，所以人在直觉上对“字符”的理解和Rust的字符概念并不一致。

由于`Unicode`都是4个字节编码，因此字符类型也是占用4个字节：

```rust
fn main() {
    let x = '中';
    println!("字符'中'占用了{}字节的内存大小",std::mem::size_of_val(&x));
}
```



输出如下：

```rust
fn main() {
    let x = '中';
    println!("字符'中'占用了{}字节的内存大小",std::mem::size_of_val(&x));
}
```

#### 注：Rust的字符只能用`''`来表示，`“”`是留给字符串的。

### 布尔(bool)

Rust中的布尔类型有两个可能的值：`true`和`false`，布尔值占用内存的大小为1字节：

``` rust
fn main() {
    let t = true;
    let f: bool = false; // 使用类型标注,显式指定f的类型
    if f {
        println!("这是段毫无意义的代码");
    }
}
```

使用布尔类型的场景主要在于流程控制，例如上述代码中的`if`就是其中之一。

### 单元类型

单元类型就是`()`，唯一值也是`()`

`Main`函数就返回这个单元类型`()`，你不能`main`函数无返回值，因为没有返回值的函数在Rust中是有单独定义的：`发散函数（diverge function)`，顾名思义，无法收敛的函数。

例如常见的`println!()`的返回值也是单元类型`()`

再比如，可以用`()`作为`map`的值，标识我们不关注具体的值，只关注`key`。这种用法和GO语言的`struct{}`类似，可以作为一个值用来占位，但是完全不占用任何内存

# 语句和表达式

Rust的函数体是由于一系列语句组成。最后由一个表达式来返回值，例如：

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```

语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此再上述函数体的三行代码中，前两号是语句，最后一行是表达式。

对于Rust语言而言，**这种基于语句(statement）和表达式(expression)的方式是非常重要的，需要明确区分这两个概念**，但是对于很多其它语言而言，这两个往往无需区分。这基于表达式是函数式语言的重要特征，表达式总要返回值。

## 语句

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。

由于`let`是语句，因此不能将`let`语句赋值给其它值，如下形式是错误的：

```rust
let b=(let a=8);
```

```Rust
error: expected expression, found statement (`let`) // 期望表达式，却发现`let`语句
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement `let`是一条语句

error[E0658]: `let` expressions in this position are experimental
          // 下面的 `let` 用法目前是试验性的，在稳定版中尚不能使用
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information
  = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`


```

