



# 变量绑定与解构

## [Rust的圣经](https://course.rs/basic/variable.html)

## 为什么要手动设置变量的可变性？

* Rust可以支持声明可变的变量， 也可以支持声明不可变的变量，兼容了灵活性与安全性。

* 一切选择皆为权衡，两者都要的权衡就是：意味着Rust语言底层代码的实现复杂度大幅提升了
* 运行性能上的提升，将本身无需改变的变量声明为不可变正在运行期会避免一些多余的<kbd>runtime</kbd>检查。

## 变量命名

Rust的一些关键字能被保留给Rust使用，所以他们不能用作变量或函数的名称，在[附录A](https://course.rs/appendix/keywords.html) 中找到关键字列表.

### 变量绑定

Rust中，用`let a ="hello world"`,进行变量的绑定，这里涉及到Rust最核心的原则—所有权，简单来讲，任何内存对象都是有主人的，且一般情况下完全属于它的主任，绑定就是给这个对象绑定一个变量，让这个变量成为它的的主人，

### 变量可变性

Rust的变量在默认情况下是<b>不可变的</b>，可以通过`mut`关键字让变量变为<b>可变的</b>.

如果变量a不可变，那么一旦为它绑定值，就不能在修改a。比如：

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);

```

保存后运行，显示的是一条错误提示，具体的错误原因是 `cannot assign twice to immutable variable x`（无法对不可变的变量进行重复赋值），因为我们想为不可变的 `x` 变量再次赋值。

这种错误是为了避免无法预期的错误发生在变量上，一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却改变了这个值，在实际开发中，这个错误是很难被发现的，特别是在多线程编程中。

这种规则让我们的代码更清晰，只有向让变量改变时才会改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。

但是可变性也很重要，在Rust中，可变性很简单，只要在变量名前加一个`mut`即可，而且这种显示的声明方式还会给后来人传达这样的信息：嗯，这个变量在代码部分会发生改变。

为了让变量声明为可变，将src/main.rs改为以下内容

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配），而可变变量最大的好处就是使用上灵活行和性能上提升了。

例如，在使用大型数据结构或者热点代码路径（被大量频繁调用）的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰。

### 使用下划线开头忽略未使用的变量

如果创建了一个变量但不使用，Rust会给一个警告，因为可能是BUG，但是有时创建一个不会被使用的变量还是有用的，比如，在设计一个原型或者一个项目，这是<b>你希望告诉Rust不要警告未使用的变量，为此可以用下划线作为变量名的开头：

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

运行后，两个变量都是只有声名，没有使用，但是编译器却给出了y未被使用的警告，充分说明了_ 变量名前缀在发挥作用。

更多关于\_x的使用信息，在[全模式列表 - Rust语言圣经(Rust Course)](https://course.rs/basic/match-pattern/all-patterns.html?highlight=_#使用下划线开头忽略未使用的变量)

### 变量解构

`let`表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### 解构式赋值

在Rust 1.59版本后，可以在赋值语句的左式中使用元组、切片和结构体模式了

```rust
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```

这种使用方式跟之祈安的`let`保持了一致性，但是`let`会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。

注意：使用+=的赋值语句还不吃之解构式赋值

```
这里用到了模式匹配的一些语法，如果大家看不懂没关系，可以在学完模式匹配章节后，再回头来看。
```

### 变量和常量之间的差异

常量（constant）与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值。但是常量和变量之间存在一些差异

* 常量不允许使用`mut`<b>常量不仅仅默认不可变，而且自始至终不可变</b>，因为常量再编译完成后，已经确定它的值。
* 常量使用`const`关键字而不是`let`关键字来声明，并且值得类型<b>必须</b>标注。

下面是一个常量声明的例子，其常量名为`MAX_POINTS`,值设置为100，000.（Rust常量的命名约定是全部字母都是用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）：

```rust
const MAX_POINTS:u32 = 100,000;
```

常量可以再任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用，例如游戏中允许玩家专区的最大点数或光速。

```
在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于的代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，也只需要在代码中更改一处即可
```

### 变量遮蔽

Rust允许声明相同的变量名，在后面声明的变量会遮蔽掉前面生命的，如下所示：

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

这个程序首先将数值 `5` 绑定到 `x`，然后通过重复使用 `let x =` 来遮蔽之前的 `x`，并取原来的值加上 `1`，所以 `x` 的值变成了 `6`。第三个 `let` 语句同样遮蔽前面的 `x`，取之前的值并乘上 `2`，得到的 `x` 最终值为 `12`

这和`mut`变量的使用是不同的，第二个`let`生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，设计一次内存对象的再分配，而`mut`声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。

变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法在访问到之祈安的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。

加入，假设有一个程序要统计一个空格字符串的空格数量：

```rust
// 字符串类型
let spaces = "   ";
// usize数值类型
let spaces = spaces.len();

```

这种结构时允许的，因为第一个`spaces`变量是一个字符串类型，第二个`spaces`变量是一个全新的变量，且和第一个具有相同的变量名，且是一个数值类型，所以变量遮蔽可以帮我们节省时间，不用去想`spaces_str`和`spaces_num`此类的变量名；相反我们可以重复使用更简单的`spaces`变量名，如果不用`let`:

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

显然，Rust对类型的要求很严格，不允许将整数类型`usize`赋值给字符串类型。`usize`是一种CPU相关的整数类型，在[数值类型 - Rust语言圣经(Rust Course)](https://course.rs/basic/base-type/numbers.html#整数类型)中有详细介绍



